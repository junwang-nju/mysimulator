
#ifndef _Random_MT_Standard_Interface_H_
#define _Random_MT_Standard_Interface_H_

#include "vector/interface.h"

namespace mysimulator {

  struct MT_Standard {

    typedef MT_Standard Type;

    static const unsigned int N=624;
    static const unsigned int M=397;
    static const unsigned int dNM=N-M;
    static const unsigned int NmOne=N-1;
    static const unsigned int MmOne=M-1;
    static const unsigned int MatrixA=0x9908B0DFUL;
    static const unsigned int UppMask=0x80000000UL;
    static const unsigned int LowMask=0x7FFFFFFFUL;
    static const unsigned int Mag01[2];
    static const unsigned int Mask32b=0xFFFFFFFFUL;

    unsigned int s[N];
    unsigned int sl;

    MT_Standard() : s(),sl(0) {}
    MT_Standard(const Type&) { Error("Copier of MT_Standard Disabled!"); }
    Type& operator=(const Type&) {
      Error("Operator= for MT_Standard Disabled!");
      return *this;
    }
    ~MT_Standard() { clearData(); }

    void clearData() {
      for(unsigned int i=0;i<N;++i) s[i]=0;
      sl=0;
    }
    void init(const unsigned int seed) {
      clearData();
      s[0]=seed&Mask32b;
      unsigned int r=s[0];
      for(sl=1;sl<N;++sl) {
        r=1812433253UL*(r^(r>>30))+sl;
        r&=Mask32b;
        s[sl]=r;
      }
      sl=1;
    }
    void init(const unsigned int* key, const unsigned int nkey,
              const unsigned int off=uZero, const int step=iOne) {
      assert(IsValid(key));
      init(19650218UL);
      unsigned int i,j,k,g,r;
      i=1;
      j=0;
      g=off;
      r=s[0];
      k=(N>nkey?N:nkey);
      for(;k;--k) {
        r=(s[i]^((r^(r>>30))*1664525UL))+key[g]+j;
        r&=Mask32b;
        s[i]=r;
        ++i;
        ++j;
        g+=step;
        if(i>=N)    { s[0]=r; i=1; }
        if(j>=nkey) { j=0;  g=off; }
      }
      for(k=NmOne;k;--k) {
        r=(s[i]^((r^(r>>30))*1566083941UL))-i;
        r&=Mask32b;
        s[i]=r;
        ++i;
        if(i>=N)  { s[0]=r; i=1; }
      }
      s[0]=UppMask;
      sl=1;
    }
    void init(Vector<unsigned int>& key) { init(key.pdata,key.size); }

    template <typename T>
    const T rand() {
      Error("This type of data cannot be generated by MT_Standard!");
      return static_cast<T>(cZero);
    }

    const double doubleClose0Close1();
    const double doubleClose0Open1();
    const double doubleOpen0Open1();
    const double double53bitSlow();
    const long double longdouble63bitSlow();

  };

  const unsigned int MT_Standard::Mag01[2]={0x0UL,MT_Standard::MatrixA};

  bool IsValid(const MT_Standard& G) { return G.sl!=0; }
  void release(MT_Standard& G) { G.clearData(); }

  template <>
  const unsigned int MT_Standard::rand<unsigned int>() {
    unsigned int u;
    if(sl>=N) {
      unsigned int k;
      for(k=0;k<dNM;++k) {
        u=(s[k]&UppMask)|(s[k+1]&LowMask);
        s[k]=s[k+M]^(u>>1)^Mag01[u&0x1UL];
      }
      for(;k<NmOne;++k) {
        u=(s[k]&UppMask)|(s[k+1]&LowMask);
        s[k]=s[k-dNM]^(u>>1)^Mag01[u&0x1UL];
      }
      u=(s[NmOne]&UppMask)|(s[0]&LowMask);
      s[NmOne]=s[MmOne]^(u>>1)^Mag01[u&0x1UL];
      sl=0;
    }
    u=s[sl++];
    u^=(u>>11);
    u^=(u<<7)&0x9D2C5680UL;
    u^=(u<<15)&0xEFC60000UL;
    u^=(u>>18);
    return u;
  }
  template <>
  const int MT_Standard::rand<int>() {
    int i=static_cast<int>(rand<unsigned int>()>>1);
    return i;
  }
  template <>
  const double MT_Standard::rand<double>() {
    long x,y;
    x=static_cast<long>(rand<unsigned int>()>>5);
    y=static_cast<long>(rand<unsigned int>()>>6);
    double d=(x*67108864.0+y)*(1./9007199254740992.);
    return d;
  }
  template <>
  const long double MT_Standard::rand<long double>() {
    unsigned long x,y;
    x=static_cast<unsigned long>(rand<unsigned int>());
    y=static_cast<unsigned long>(rand<unsigned int>());
    long double ld=
      static_cast<long double>(x*(1./4294967296.0))+
      static_cast<long double>(y*(1./18446744073709551616.0))+
      (0.5+0.5/4294967296.0);
    return ld;
  }

  const double MT_Standard::doubleClose0Close1() {
    int i=static_cast<int>(rand<unsigned int>());
    double d=static_cast<double>(i)*(1./4294967295.)+
             (0.5+0.5/4294967295.);
    return d;
  }
  const double MT_Standard::doubleClose0Open1() {
    int i=static_cast<int>(rand<unsigned int>());
    double d=static_cast<double>(i)*(1./4294967296.)+0.5;
    return d;
  }
  const double MT_Standard::doubleOpen0Open1() {
    int i=static_cast<int>(rand<unsigned int>());
    rand<unsigned int>();
    double d=static_cast<double>(i)*(1./4294967296.)+
             (0.5+0.5/4294967296.);
    return d;
  }

  const double MT_Standard::double53bitSlow() {
    unsigned int x,y;
    x=rand<unsigned int>()>>5;
    y=rand<unsigned int>()>>6;
    double d=(static_cast<double>(x)*67108864.0+static_cast<double>(y))*
             (1./9007199254740992.);
    return d;
  }
  const long double MT_Standard::longdouble63bitSlow() {
    unsigned int x,y;
    x=rand<unsigned int>();
    y=rand<unsigned int>();
    long double ld=(x|(static_cast<unsigned long long int>(y)<<32))*
                   (1./18446744073709551616.0L);
    return ld;
  }

}

#endif

